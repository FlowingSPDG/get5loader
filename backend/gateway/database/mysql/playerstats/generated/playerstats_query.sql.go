// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: playerstats_query.sql

package playerstats_gen

import (
	"context"
	"strings"
)

const getPlayerStats = `-- name: GetPlayerStats :one
SELECT id, match_id, map_id, team_id, steam_id, name, kills, deaths, roundsplayed, assists, flashbang_assists, teamkills, suicides, headshot_kills, damage, bomb_plants, bomb_defuses, v1, v2, v3, v4, v5, k1, k2, k3, k4, k5, firstdeath_ct, firstdeath_t, firstkill_ct, firstkill_t FROM player_stats
WHERE id = ? LIMIT 1
`

func (q *Queries) GetPlayerStats(ctx context.Context, id string) (PlayerStat, error) {
	row := q.db.QueryRowContext(ctx, getPlayerStats, id)
	var i PlayerStat
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.MapID,
		&i.TeamID,
		&i.SteamID,
		&i.Name,
		&i.Kills,
		&i.Deaths,
		&i.Roundsplayed,
		&i.Assists,
		&i.FlashbangAssists,
		&i.Teamkills,
		&i.Suicides,
		&i.HeadshotKills,
		&i.Damage,
		&i.BombPlants,
		&i.BombDefuses,
		&i.V1,
		&i.V2,
		&i.V3,
		&i.V4,
		&i.V5,
		&i.K1,
		&i.K2,
		&i.K3,
		&i.K4,
		&i.K5,
		&i.FirstdeathCt,
		&i.FirstdeathT,
		&i.FirstkillCt,
		&i.FirstkillT,
	)
	return i, err
}

const getPlayerStatsByMapStat = `-- name: GetPlayerStatsByMapStat :many
SELECT id, match_id, map_id, team_id, steam_id, name, kills, deaths, roundsplayed, assists, flashbang_assists, teamkills, suicides, headshot_kills, damage, bomb_plants, bomb_defuses, v1, v2, v3, v4, v5, k1, k2, k3, k4, k5, firstdeath_ct, firstdeath_t, firstkill_ct, firstkill_t FROM player_stats
WHERE map_id = ?
`

func (q *Queries) GetPlayerStatsByMapStat(ctx context.Context, mapID string) ([]PlayerStat, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerStatsByMapStat, mapID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerStat
	for rows.Next() {
		var i PlayerStat
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.MapID,
			&i.TeamID,
			&i.SteamID,
			&i.Name,
			&i.Kills,
			&i.Deaths,
			&i.Roundsplayed,
			&i.Assists,
			&i.FlashbangAssists,
			&i.Teamkills,
			&i.Suicides,
			&i.HeadshotKills,
			&i.Damage,
			&i.BombPlants,
			&i.BombDefuses,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.K1,
			&i.K2,
			&i.K3,
			&i.K4,
			&i.K5,
			&i.FirstdeathCt,
			&i.FirstdeathT,
			&i.FirstkillCt,
			&i.FirstkillT,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsByMapStats = `-- name: GetPlayerStatsByMapStats :many
SELECT id, match_id, map_id, team_id, steam_id, name, kills, deaths, roundsplayed, assists, flashbang_assists, teamkills, suicides, headshot_kills, damage, bomb_plants, bomb_defuses, v1, v2, v3, v4, v5, k1, k2, k3, k4, k5, firstdeath_ct, firstdeath_t, firstkill_ct, firstkill_t FROM player_stats
WHERE map_id IN (/*SLICE:map_ids*/?)
`

func (q *Queries) GetPlayerStatsByMapStats(ctx context.Context, mapIds []string) ([]PlayerStat, error) {
	query := getPlayerStatsByMapStats
	var queryParams []interface{}
	if len(mapIds) > 0 {
		for _, v := range mapIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:map_ids*/?", strings.Repeat(",?", len(mapIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:map_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerStat
	for rows.Next() {
		var i PlayerStat
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.MapID,
			&i.TeamID,
			&i.SteamID,
			&i.Name,
			&i.Kills,
			&i.Deaths,
			&i.Roundsplayed,
			&i.Assists,
			&i.FlashbangAssists,
			&i.Teamkills,
			&i.Suicides,
			&i.HeadshotKills,
			&i.Damage,
			&i.BombPlants,
			&i.BombDefuses,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.K1,
			&i.K2,
			&i.K3,
			&i.K4,
			&i.K5,
			&i.FirstdeathCt,
			&i.FirstdeathT,
			&i.FirstkillCt,
			&i.FirstkillT,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsByMatch = `-- name: GetPlayerStatsByMatch :many
SELECT id, match_id, map_id, team_id, steam_id, name, kills, deaths, roundsplayed, assists, flashbang_assists, teamkills, suicides, headshot_kills, damage, bomb_plants, bomb_defuses, v1, v2, v3, v4, v5, k1, k2, k3, k4, k5, firstdeath_ct, firstdeath_t, firstkill_ct, firstkill_t FROM player_stats
WHERE match_id = ?
`

func (q *Queries) GetPlayerStatsByMatch(ctx context.Context, matchID string) ([]PlayerStat, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerStatsByMatch, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerStat
	for rows.Next() {
		var i PlayerStat
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.MapID,
			&i.TeamID,
			&i.SteamID,
			&i.Name,
			&i.Kills,
			&i.Deaths,
			&i.Roundsplayed,
			&i.Assists,
			&i.FlashbangAssists,
			&i.Teamkills,
			&i.Suicides,
			&i.HeadshotKills,
			&i.Damage,
			&i.BombPlants,
			&i.BombDefuses,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.K1,
			&i.K2,
			&i.K3,
			&i.K4,
			&i.K5,
			&i.FirstdeathCt,
			&i.FirstdeathT,
			&i.FirstkillCt,
			&i.FirstkillT,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsBySteamID = `-- name: GetPlayerStatsBySteamID :many
SELECT id, match_id, map_id, team_id, steam_id, name, kills, deaths, roundsplayed, assists, flashbang_assists, teamkills, suicides, headshot_kills, damage, bomb_plants, bomb_defuses, v1, v2, v3, v4, v5, k1, k2, k3, k4, k5, firstdeath_ct, firstdeath_t, firstkill_ct, firstkill_t FROM player_stats
WHERE steam_id = ?
`

func (q *Queries) GetPlayerStatsBySteamID(ctx context.Context, steamID uint64) ([]PlayerStat, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerStatsBySteamID, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerStat
	for rows.Next() {
		var i PlayerStat
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.MapID,
			&i.TeamID,
			&i.SteamID,
			&i.Name,
			&i.Kills,
			&i.Deaths,
			&i.Roundsplayed,
			&i.Assists,
			&i.FlashbangAssists,
			&i.Teamkills,
			&i.Suicides,
			&i.HeadshotKills,
			&i.Damage,
			&i.BombPlants,
			&i.BombDefuses,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.K1,
			&i.K2,
			&i.K3,
			&i.K4,
			&i.K5,
			&i.FirstdeathCt,
			&i.FirstdeathT,
			&i.FirstkillCt,
			&i.FirstkillT,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayerStatsByTeam = `-- name: GetPlayerStatsByTeam :many
SELECT id, match_id, map_id, team_id, steam_id, name, kills, deaths, roundsplayed, assists, flashbang_assists, teamkills, suicides, headshot_kills, damage, bomb_plants, bomb_defuses, v1, v2, v3, v4, v5, k1, k2, k3, k4, k5, firstdeath_ct, firstdeath_t, firstkill_ct, firstkill_t FROM player_stats
WHERE team_id = ?
`

func (q *Queries) GetPlayerStatsByTeam(ctx context.Context, teamID string) ([]PlayerStat, error) {
	rows, err := q.db.QueryContext(ctx, getPlayerStatsByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerStat
	for rows.Next() {
		var i PlayerStat
		if err := rows.Scan(
			&i.ID,
			&i.MatchID,
			&i.MapID,
			&i.TeamID,
			&i.SteamID,
			&i.Name,
			&i.Kills,
			&i.Deaths,
			&i.Roundsplayed,
			&i.Assists,
			&i.FlashbangAssists,
			&i.Teamkills,
			&i.Suicides,
			&i.HeadshotKills,
			&i.Damage,
			&i.BombPlants,
			&i.BombDefuses,
			&i.V1,
			&i.V2,
			&i.V3,
			&i.V4,
			&i.V5,
			&i.K1,
			&i.K2,
			&i.K3,
			&i.K4,
			&i.K5,
			&i.FirstdeathCt,
			&i.FirstdeathT,
			&i.FirstkillCt,
			&i.FirstkillT,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
